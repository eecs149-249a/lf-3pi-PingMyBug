target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
}
  
import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"
import GyroAngle from "lib/IMU.lf"
import Encoders from "lib/Encoders.lf"

preamble {=
    #define WHEEL_DIAMETER 0.03175  // in meters
    #define PI 3.14159265358979323846
=}
  
  
  reactor AngleToDistance {
    input angleChange: int32_t
    output distance: float
    
    reaction(angleChange) -> distance {=
        float D = (angleChange->value / 360.0) * 3.14159265359 * 0.03175;
        lf_set(distance->value, D);
    =}
  }

main reactor {
    preamble {=
        #define FORWARD_SPEED 0.1
        #define TURN_SPEED 0.1
        #define TURN_ANGLE 90.0
        #define DRIVE_DISTANCE 0.5  // in meters
    =}

    display = new Display()
    motors = new Motors()
    gyro = new GyroAngle()
    encoders = new Encoders()
    angleToDistanceLeft = new AngleToDistance()
    angleToDistanceRight = new AngleToDistance()

    timer t(0, 100ms)

    state lastAngle: float = 0.0;
    state lastLeft: float = 0.0;
    state lastRight: float = 0.0;

    reaction(t) -> gyro.trigger, encoders.trigger {=
        lf_set(gyro.trigger, true);
        lf_set(encoders.trigger, true);
    =}

    reaction(startup) -> display.line0 {=
        lf_set(display.line0, "Square Drive");
    =}

    encoders.left -> angleToDistanceLeft.angleChange;
    encoders.right -> angleToDistanceRight.angleChange;

    initial mode DRIVINGFORWARD {
        reaction(t, angleToDistanceLeft.distance, angleToDistanceRight.distance, gyro.z) -> motors.left_power, motors.right_power, TURNING {=
            // Drive forward
            lf_set(motors.left_power, FORWARD_SPEED);
            lf_set(motors.right_power, FORWARD_SPEED);

            if (angleToDistanceLeft.distance->value - self->lastLeft >= DRIVE_DISTANCE && angleToDistanceRight.distance->value - self->lastRight >= DRIVE_DISTANCE) {
                // Reset distance and angle for next mode
                
                self->lastAngle = gyro.z->value;
                lf_set_mode(TURNING);
            }
        =}
    }

    mode TURNING {
        reaction(t, angleToDistanceLeft.distance, angleToDistanceRight.distance, gyro.z) -> motors.left_power, motors.right_power, DRIVINGFORWARD {=
            // Turn the robot
            lf_set(motors.left_power, -TURN_SPEED);
            lf_set(motors.right_power, TURN_SPEED);

            // Check if the robot has turned 90 degrees
            if (fabs(gyro.z->value - self->lastAngle) >= TURN_ANGLE) {
                // Reset distance and angle for next mode
                self->lastLeft = angleToDistanceLeft.distance->value;
                self->lastRight = angleToDistanceRight.distance->value;
                lf_set_mode(DRIVINGFORWARD);
            }
        =}
    }
}